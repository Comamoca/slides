#+STARTUP: fold

** import

#+begin_src typst-ts :tangle ./main.typ
  #import "@preview/touying:0.6.1": *
  // #import themes.simple: *
  #import "../../lib/theme.typ": *
  #import "../../lib/color.typ": *
  #import "@preview/codelst:2.0.2": sourcecode
#+end_src

** 設定

#+begin_src typst-ts :tangle ./main.typ 
  #show: comamoca-theme.with(total-slides: 9, primary: unnamed-blue)

  #let icode(name) = text(fill: faff-pink, raw(block: false, name.text))

  #let codelst-sourcecode = sourcecode
  #let sourcecode = codelst-sourcecode.with(
    frame: block.with(
      fill: underwater-blue,
      stroke: 1pt + faff-pink,
      radius: 5pt,
      inset: (x: 10pt, y: 5pt)
    )
  )

  #let center-image(path, width: 80%) = align(center, pad(y: 1em, align(center, image(
    path,
    width: width,
  ))))
  #set page(fill: underwater-blue)
  #set text(font: "Noto Sans", fill: white)

  #set list(spacing: 1.2em)

  // #set text(font: "UDEV Gothic NF")
  #show regex("[\p{scx:Han}\p{scx:Hira}\p{scx:Kana}]"): set text(
    font: "UDEV Gothic NF",
  )
#+end_src

** タイトル

#+begin_src typst-ts :tangle ./main.typ
  #title-slide(
    [
      #align(center)[
        #block[
          #set align(left)
          #v(3em)
          #stack(
            dir: ttb,
            spacing: 1em,
            text("Gleamという選択肢", size: 2em),
            text("6/15 関数型まつり 2日目"),
          )
          #v(2em)
          #stack(dir: ltr, image("./images/icon.png", width: 10%), h(0.5em), text("こまもか", size: 1.4em))
      ]
      ]
    ]
  )
#+end_src

** 自己紹介

#+begin_src typst-ts :tangle ./main.typ 
  == 自己紹介

  #stack([こまもか], text("Twitter: @Comamoca_"), spacing: 9pt)


  #align(center)[
    #v(1em)
    #image("./images/icon.png", width: 20%)
    #text("\ Twitterから来ました! /")
  ]
#+end_src

#+begin_src typst-ts :tangle ./main.typ 
  #center-image("./images/gleam-reverse-lookup.png")
  #center-image("./images/gleam-poem.png") 
  #center-image("./images/gleam-articles-list.png") 
  #center-image("./images/gleam-garnet.png") 
#+end_src

Gleamを2年くらい追っている。
色々ツールを作ったり記事を書いたりしている。

** 注意点

#+begin_src typst-ts :tangle ./main.typ
  == 注意点
  Gleam v1.11.0を前提にしています。 \
  Gleam Playgroundは現時点でv1.11.0に対応していないため、一部構文はエラーになる可能性があります。
  主に#icode[echo]キーワードなどが該当します。

  また、 表示の都合上importなどを省略している箇所があります。
#+end_src

** Gleamとは

#+begin_src typst-ts :tangle ./main.typ
  == Gleamとは

  Louis Pilfold氏が開発している、静的型付けの関数型言語\
  シンプルな構文とErlang VMに基づいた並列性が特徴

  #pagebreak() 
#+end_src

Erlang VMのみならずJSでも動かせる。

#+begin_src typst-ts :tangle ./main.typ
  #focus-slide[
      シンプル...Goと何が違うの？
  ]
#+end_src

ここでちょっと思想の話になります。

シンプルというとGoが思い浮かぶ方もいると思いますが、何が違うのかというとシンプルに対する視点が違います。

6 yearts with gleamっていう記事があるのだけど、そこに作者さんのこういう言葉が紹介されています。

#+begin_src typst-ts :tangle ./main.typ
  == Gleamとは

    #center-image("./images/6-years-with-gleam.png", width: 55%)
    #align(center)[#text("https://crowdhailer.me/2024-10-04/6-years-with-gleam/", 10pt)]

    #pagebreak()

    #align(horizon)[
        #quote(block: true, attribution: [Louis Pilfold])[
            Gleam is Go ideas but from the perspective of a FP nerd instead of a C nerd
        ]
    ]

    #pagebreak() 
#+end_src


#+begin_src typst-ts :tangle ./main.typ
    == 意訳するなら

    #align(horizon)[
        #quote(block: true, attribution: [Louis Pilfold])[
            GleamはGoの設計思想を取り入れているけど、Cオタクの視点じゃなくてFPオタクの視点で解釈した言語だ。
        ]
    ]
#+end_src

例えばGoはループをforで行うけれど、Gleamにはforはなく再帰で行います。
このアプローチはとても関数型的。

** Gleamの特徴

#+begin_src typst-ts :tangle ./main.typ 
  == Gleamの特徴

  - シンプルな構文
  - 関数型言語由来の関数が多いためコードがスッキリする
  - エラーメッセージが親切
  - Erlang VM / JS Runtimeで動く

#+end_src

Gleamは構文がシンプルなので、ある程度プログラミングに慣れている人は半日程度で構文を把握できる。
また、`map`や`reduce`等関数型言語由来の関数が使えるためコードがとてもスッキリするという特徴がある。

Gleamはユーザーフレンドリーに重きを置いており、コンパイラのエラーメッセージなどが非常に読みやすくなっている。

エラーメッセージの一例を以下に示してみる。

#+begin_src typst-ts :tangle ./main.typ 
        == エラーメッセージの例

  #block(
      stroke: 1pt,
      inset: 0.55em,
      radius: 5pt, 
      fill: white,
    )[
  #text(size: 14pt, fill: black, font: "UDEV Gothic NF")[
  ```text
                error: Unknown variable
                  ┌─ /src/main.gleam:3:8
                  │
                3 │   echo prson
                  │        ^^^^^ Did you mean person?

                The name prson is not in scope here.

                warning: Unused variable
                  ┌─ /src/main.gleam:2:7
                  │
                2 │   let person = "Jhon"
                  │       ^^^^^^ This variable is never used

                Hint: You can ignore it with an underscore: _person.
                ```
  ]]
#+end_src

`person`を`prson`とtypoしてしまっているのが見て取れる。

** 開発環境

#+begin_src typst-ts :tangle ./main.typ 
  == LSP

  #list(
    [型アノテーションの追加],
    [#icode[import]文の自動追加],
    [#icode[case]における不足してるパターンの追加],
    [パイプ形式でへの自動変換],
  )

  #center-image("images/2024-07-14-gleam-release-v1-3-0.png")
#+end_src

また、LSPによるサポートも充実している。
コードアクションの一例としてこれらのコードアクションがある。

最近ではJSONのデコーダーを自動生成するアクションなども追加されていて、開発体験がますます向上している。
(`gleam/json`ライブラリをプロジェクトに追加しないと発動しない)

詳しくはZennで

** 構文

#+begin_src typst-ts :tangle ./main.typ 
  == 構文

  - ifとかforがない
  - コールバックの構文糖(use構文)
  - ブロック構文
  - パターンマッチ
  - パイプライン演算子
#+end_src

#+begin_src typst-ts :tangle ./main.typ 
  == use構文
  これ一つで

  - 例外処理
  - 非同期処理
  - early return
  - middleware

  などが表現できる
#+end_src

#+begin_src typst-ts :tangle ./main.typ
  #center-image("images/gleam-use-syntax.png")
#+end_src

個人的に一番Gleamらしいと思う構文

#+begin_src typst-ts :tangle ./main.typ
  == 例えば

  #sourcecode()[
  ```rust
  let val = True
  case True {
    True -> "これはTrue"
    False -> "これはFalse"
  }
  ```
  ]

  #pagebreak()
#+end_src

#+begin_src typst-ts :tangle ./main.typ
  #sourcecode()[
   ```rust
   import gleam/list
   
   pub fn main() {
    list.range(0, 10)
    |> list.map(fn (n) { n * 2 })
    |> list.filter(fn (n) {n % 3 == 0})
    |> echo
   }
   ```]
#+end_src

完全に網羅しないとコンパイルエラーが発生する
-> 網羅性がコンパイラで検証できる

#+begin_src typst-ts :tangle ./main.typ
  #center-image("./images/gleam-tour-for-typescript-user.png")
#+end_src

詳しくはZennで

** 開発環境


#+begin_src typst-ts :tangle ./main.typ 
  == 開発環境
  #align(center)[
      #box(radius: 5pt, stroke: faff-pink)[
          #center-image("./images/install-gleam.png", width: 55%)
      ]
  ]

  #align(center)[#text("https://gleam.run/getting-started/installing/", 10pt)] 
#+end_src

環境構築についてですが、基本的に公式ドキュメントを読めばなんとかなります。

#+begin_src typst-ts :tangle ./main.typ 
  == インストール
  - brew
  - AUR
  - apt
  - scoop
  - Nix
#+end_src

主要なパッケージマネージャには大体対応しています。
Nixだけはちょっと注意が必要で、nixpkgsにあるGleamは古いのと現状overlayがないので自分でnix式を書いてbuildする必要があります。

#+begin_src typst-ts :tangle ./main.typ 
  == 拡張機能
  - VSCode
  - Vim
  - Emacs
  - Zed
#+end_src

拡張機能は公式でこの4つがサポートされています。

** エコシステム

#+begin_src typst-ts :tangle ./main.typ
  #focus-slide[
      Gleamのエコシステム
  ]
#+end_src

*** Webアプリケーション

#+begin_src typst-ts :tangle ./main.typ 
  == Webサーバー
  - #icode[gleam/http]
  - #icode[mist]
  - #icode[wisp]
#+end_src

gleam/httpは公式パッケージで、webアプリケーションプログミングに必要な型が定義されている。
gleamのライブラリは一般的にこのパッケージをベースに作られているのでライブラリ間で型の互換性が確保されている。
webサーバーと合わせて紹介したけれど、webクライアントもこれをベースに開発されている。

型のみを定義することでErlang VMでもJS Runtimeでもサーバーやクライアントを自由に実装できる。

mistというのがデファクトなwebサーバーになっていて、Gleamで書かれている。
wispはmistをベースに定型的な処理を提供している。

#+begin_src typst-ts :tangle ./main.typ 
  == ルーティング

  #sourcecode()[
  ```rust
  import gleam/string_tree
  import hello_world/app/web
  import wisp.{type Request, type Response}

  pub fn handle_request(req: Request) -> Response {
    // ["tasks", "2"]
    case wisp.path_segments(req) {
      [] -> index(req)
      ["hello"] -> greet(req)
      ["tasks", id] -> show_task(req, id)
      _ -> wisp.not_found()
    }
  }
  ```]
#+end_src


path_segmentsっていう関数を使うとリクエストが来たpathを文字列のリストに分割してくれる。
それをパータンマッチしてルーティングを行う。

#+begin_src typst-ts :tangle ./main.typ 
  == ミドルウェア

  #sourcecode()[
  [
  ```rust
  pub fn greet_middleware(req: Request, handler: fn (Request) -> Response) -> Response {
    io.println("Hello!")
  }

  pub fn handle_request(req: Request) -> Response {
    use req <- greet_middleware(req)

    case wisp.path_segments(req) {
      [] -> index(req)
      _ -> wisp.not_found()
    }
  }
  ```]]
#+end_src

リクエストが来たらHello!を表示するミドルウェア


GleamのハンドラーはRequest -> Responseという形に抽象化できる

ミドルウェアは
RequestとRequestを受け取ってResponseを返す関数を受け取って、Responseを返す関数
fn (req: Request, next: fn (Request) -> Response) -> Responseに抽象化できる。

この関数はuseを適用できるため、useを複数使って連鎖的にミドルウェアを適用できます。

#+begin_src typst-ts :tangle ./main.typ 
  == Lustre
  - TEAベースのWebフレームワーク
  - 表示単位が純粋関数なため*どこでも*レンダリングできる
  - CSR, SSR, SSGが可能
  - 開発がLustre dev toolsで完結する
  - GitHub 1.6K ⭐
#+end_src

#+begin_src typst-ts :tangle ./main.typ
  #center-image("./images/gleam-lustre.png")
#+end_src

フロントエンドまわりも色々あるんですが、ボリュームの都合上紹介しきれなさそうなのでLustreに絞って紹介します。

LusterはElmアーキテクチャをベースにしたWebフレームワーク。
CSR, SSR両対応でハイドレーションも可能。

Gleamのキラーライブライリになりそうだと期待している。

以前は状態を含んだコンポーネントのコストが重かったが、最近になってweb componentsベースの実装になった影響でかなり軽くなった。


** 実例

#+begin_src typst-ts :tangle ./main.typ
  #focus-slide[
      実例
  ]
#+end_src

#+begin_src typst-ts :tangle ./main.typ
  == Gleam Packages
  #center-image("./images/gleam-packages.png", width: 65%)
#+end_src

Gleamのパッケージを検索できるサイト。
内部的にはBEAMファミリー言語向けのパッケージレジストリhex.pmのAPIを叩いている。

#+begin_src typst-ts :tangle ./main.typ
  == Gloogle
  #center-image("./images/gleam-gloogle.png", width: 65%)
#+end_src

Gleamのパッケージドキュメントを全文検索できるサイト。
ここ最近になってパフォーマンスがかなり向上した。

#+begin_src typst-ts :tangle ./main.typ
  == kirakira
  #center-image("./images/gleam-kirakira.png", width: 65%)
#+end_src

ガンダムは関係ない。
Gleamで書かれた掲示板。新規登録するには管理人に申請する必要がある。
ソースコードが公開されているので、フルスタックなアプリケーションをGleamで書く際の参考になる。


#+begin_src typst-ts :tangle ./main.typ
  == これからの展望
  - 更なる開発支援機能の追加
  - コード生成技術の発達
  - フルスタックフレームワークの発達
  - 新たなコンパイルターゲットの登場
#+end_src

フルスタックアプリケーションFWであるpevensieなど、エコシステムが成長する余地があるしこれからも成長していくだろうと思う。

#+begin_src typst-ts :tangle ./main.typ
  == 寄付について
  現在Louis Pilfold氏は*フルタイム*でGleamを開発しているのですが、残念ながら財政状況は良くないらしいです... \
  *GitHub Sponsors経由*で寄付を行えるので、Gleamを気に入ったらぜひ寄付をお願いします。
#+end_src


#+begin_src typst-ts :tangle ./main.typ
  #center-image("./images/gleam-sponsors.png", width: 70%)
  #align(center)[#text(size: 10pt, "ちなみに、寄付を行なうとブログの一番下に名前が載ります。")]
#+end_src

